<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>M4C8</title>
    <link rel="stylesheet" href="css/commun.css">
    <link rel="stylesheet" href="css/questions_styles.css">
    <link rel="stylesheet" href="css/media_queries.css">
</head>
<body>
    <header>
        <h1>Preguntas teóricas del Punto de control 8</h1>
    </header>
    <main>
<!-- 1 question -->
        <div class="question-answer">
            <div class="question-wrapper">
                <h3>1. ¿Qué tipo de bucles hay en JS?</h3>
                <div class="arrow down">&#9650;</div>
            </div>
            <div class="answer-wrapper close">
                <div class="answer-contenido">
                    <p>
                        <b class="large-text">Un ciclo</b> es una construcción en programación que permite repetir el mismo bloque de código varias veces mientras se cumpla una determinada condición.
                    </p>
                    <div class="flex-vertical">
                        <div class="text-wrapper">
                            <p>
                                <i class="underlined">Los ciclos son útiles cuando se necesita:</i>
                            </p>
                            <ul>
                                <li>recorrer los elementos de un arreglo;</li>
                                <li>realizar una tarea muchas veces (por ejemplo, contar hasta 100);</li>
                                <li>solicitar la entrada del usuario hasta que introduzca un valor correcto;</li>
                                <li>automatizar acciones repetitivas.</li>
                            </ul>
                            <br>
                            <p>
                                <i class="underlined">En JavaScript hay varios tipos principales de ciclos:</i>
                            </p>
                            <ul>
                                <li><b>for</b> - ciclo con una cantidad conocida de repeticiones de antemano.</li>
                                <li><b>while</b> - ciclo con una cantidad desconocida de repeticiones, mientras se cumpla una condición.</li>
                                <li><b>do...while</b> - como while, pero el código se ejecuta al menos una vez.</li>
                                <li><b>for...in</b> - se utiliza para recorrer las propiedades de un objeto.</li>
                                <li><b>for...of</b> - se utiliza para recorrer los valores de objetos iterables (arreglos, cadenas, etc.).</li>
                            </ul>
                            <!-- <br> -->
                        </div>
                        <div class="img-wrapper">
                            <img src="img/m4c8/loops.jpg" alt="Loops JS">
                        </div>
                    </div>
                    <hr>
                    <p>
                        &#128204; <b class="large-text">El ciclo for</b> es un ciclo universal con un contador controlado. Se usa más comúnmente cuando se sabe de antemano cuántas veces se deben repetir las acciones.
                    </p>
                    <br>
                    <p>
                        Estructura del ciclo <b>for</b>:
                    </p>
                    <pre><code>
for (variable; condición; paso) {
    // cuerpo del ciclo
}
                    </code></pre>
                    <ul>
                        <li>se ejecuta el variable (por ejemplo, let i = 0) - esta es la inicialización;</li>
                        <li>se evalúa la condición (por ejemplo, i &lt; 5) - si es true, se ejecuta el cuerpo del ciclo;</li>
                        <li>después de ejecutar el cuerpo del ciclo, se realiza el paso (por ejemplo, i++ - incremento del contador);</li>
                        <li>se vuelve a verificar la condición, y así sucesivamente.</li>
                    </ul>
                    <br>
                    <p>
                        Ejemplo:
                    </p>
                    <pre><code>
for (let i = 1; i &lt;= 3; i++) {
    console.log(`Iteración número ${i}`);
}

// Iteración número 1  
// Iteración número 2  
// Iteración número 3
                    </code></pre>
                    <br>
                    <p>
                        <i class="underlined">¿Cuándo se utiliza el ciclo <b>for</b>?</i>
                    </p>
                    <ul>
                        <li>Cuando se conoce la cantidad exacta de iteraciones.</li>
                        <li>Al recorrer un arreglo por índices.</li>
                        <li>Cuando se necesita controlar el paso (por ejemplo, i += 2, i--).</li>
                    </ul>
                    <hr>
                    <p>
                        &#128204; <b class="large-text">El ciclo while</b> ejecuta un bloque de código mientras la condición sea verdadera (true). Es útil cuando no se sabe de antemano cuántas veces se deben repetir las acciones.
                    </p>
                    <br>
                    <p>
                        Estructura del ciclo <b>while</b>:
                    </p>
                    <pre><code>
while (condición) {
  // cuerpo del ciclo
}
                    </code></pre>
                    <ul>
                        <li>primero se verifica la condición;</li>
                        <li>si la condición es true, se ejecuta el cuerpo del ciclo;</li>
                        <li>luego, se vuelve a verificar la condición;</li>
                        <li>esto se repite mientras la condición siga siendo verdadera;</li>
                    </ul>
                    <p>
                        Si la condición es <i>false</i> desde el principio, el cuerpo del ciclo no se ejecutará ni una sola vez.
                    </p>
                    <br>
                    <p>
                        Ejemplo:
                    </p>
                    <pre><code>
let number = 1;

while (number &lt;= 3) {
  console.log(`Número: ${number}`);
  number++;
}

// Número: 1  
// Número: 2  
// Número: 3
                    </code></pre>
                    <br>
                    <p>
                        <i class="underlined">¿Cuándo se utiliza el ciclo <b>while</b>?</i>
                    </p>
                    <ul>
                        <li>Cuando no sabes cuántas iteraciones serán necesarias.</li>
                        <li>Por ejemplo, al recibir datos del usuario, cuando necesitas esperar una entrada válida.</li>
                        <li>Al esperar un evento o estado (por ejemplo, la carga de datos).</li>
                    </ul>
                    <hr>
                    <p>
                        &#128204; <b class="large-text">El ciclo do...while</b> es similar al ciclo <b>while</b>, pero garantiza que el cuerpo del ciclo se ejecute al menos una vez, incluso si la condición es falsa desde el principio.
                    </p>
                    <br>
                    <p>
                        Estructura del ciclo <b>do...while</b>:
                    </p>
                    <pre><code>
do {
  // cuerpo del ciclo
} while (condición);
                    </code></pre>
                    <ul>
                        <li>se ejecuta el cuerpo del ciclo una vez;</li>
                        <li>luego se verifica la condición;</li>
                        <li>si la condición es true, el ciclo se repite;</li>
                        <li>si es false, el ciclo termina.</li>
                    </ul>
                    <br>
                    <p>
                        Ejemplo:
                    </p>
                    <pre><code>
let i = 5;

do {
  console.log(`Esto se imprimirá al menos una vez i = ${i}`);
  i++;
} while (i &lt; 3);

// Esto se imprimirá al menos una vez i = 5
                    </code></pre>
                    <br>
                    <p>
                        <i class="underlined">¿Cuándo se utiliza el ciclo <b>do...while</b>?</i>
                    </p>
                    <ul>
                        <li>Cuando necesitas asegurarte de que el cuerpo del ciclo se ejecute al menos una vez.</li>
                        <li>Por ejemplo, al pedir una contraseña antes de iniciar sesión — se debe solicitar la entrada al menos una vez.</li>
                        <li>Cuando la verificación debe hacerse después de ejecutar la acción.</li>
                    </ul>
                    <hr>
                    <p>
                        &#128204; <b class="large-text">El ciclo for...in</b> se utiliza para recorrer las propiedades de un objeto. Es útil cuando necesitas acceder a todas las propiedades de un objeto sin importar su orden.
                    </p>
                    <br>
                    <p>
                        Estructura del ciclo <b>for...in</b>:
                    </p>
                    <pre><code>
for (let clave in objeto) {
  // cuerpo del ciclo
}
                    </code></pre>
                    <ul>
                        <li>se declara una variable (por ejemplo, clave) que tomará el nombre de cada propiedad del objeto;</li>
                        <li>el cuerpo del ciclo se ejecuta para cada propiedad del objeto.</li>
                    </ul>
                    <br>
                    <p>
                        Ejemplo:
                    </p>
                    <pre><code>
let user = {
  nombre: 'Elena',
  edad: 30,
  ciudad: 'Kazan'
};

for (let clave in user) {
  console.log(clave + ": " + user[clave]);
}

// nombre: Elena
// edad: 30
// ciudad: Kazan
                    </code></pre>
                    <br>
                    <p>
                        <i class="underlined">¿Cuándo se utiliza el ciclo <b>for...in</b>?</i>
                    </p>
                    <ul>
                        <li>Cuando necesitas recorrer las propiedades de un objeto.</li>
                        <li>Cuando no importa el orden de las propiedades.</li>
                        <li>Cuando no necesitas acceder a los valores de un arreglo por índice.</li>
                    </ul>
                    <hr>
                    <p>
                        &#128204; <b class="large-text">El ciclo for...of</b> se utiliza para recorrer los valores de objetos iterables (arreglos, cadenas, etc.). Es útil cuando necesitas acceder a los valores sin preocuparte por los índices.
                    </p>
                    <br>
                    <p>
                        Estructura del ciclo <b>for...of</b>:
                    </p>
                    <pre><code>
for (let variable of colección) {
  // cuerpo del ciclo
}
                    </code></pre>
                    <ul>
                        <li>se declara una variable (por ejemplo, variable) que tomará el valor de cada elemento de la colección;</li>
                        <li>el cuerpo del ciclo se ejecuta para cada elemento de la colección.</li>
                    </ul>
                    <br>
                    <p>
                        Ejemplo:
                    </p>
                    <pre><code>
let names = ['Anna', 'Boris', 'Víctor'];

for (let name of names) {
  console.log(`Hola, ${name}!`);
}

// Hola, Anna!
// Hola, Boris!
// Hola, Víctor!
                    </code></pre>
                    <br>
                    <p>
                        <i class="underlined">¿Cuándo se utiliza el ciclo <b>for...of</b>?</i>
                    </p>
                    <ul>
                        <li>Cuando necesitas recorrer los valores de un objeto iterable.</li>
                        <li>Cuando no necesitas preocuparte por los índices.</li>
                        <li>Cuando no necesitas acceder a las propiedades del objeto.</li>
                    </ul>
                </div>
                <div class="arrow-2">&#9650;</div>
            </div>
        </div>
<!-- 2 question -->
        <div class="question-answer">
            <div class="question-wrapper">
                <h3>2. ¿Cuáles son las diferencias entre const, let y var?</h3>
                <div class="arrow down">&#9650;</div>
            </div>
            <div class="answer-wrapper close">
                <div class="answer-contenido">
                    <p>
                        Cuando comenzamos a aprender a programar en JavaScript, una de las primeras cosas con las que nos encontramos es la declaración de variables. En JavaScript, existen tres palabras clave para esto: <b>let</b>, <b>const</b> y <b>var</b>. Todas se usan para crear variables, pero entre ellas existen diferencias importantes. Para entender mejor cómo y cuándo usar cada una de ellas, vamos a analizar cada una por separado.
                    </p>
                    <div class="img-wrapper">
                        <img src="img/m4c8/var_let_const.jpeg" alt="Variables JS">
                    </div>
                    <hr>
                    <p>
                        &#128204; <b class="large-text">var</b> - es una palabra clave que se utilizaba para declarar variables antes de la llegada de ES6 (la nueva versión de JavaScript que se lanzó en 2015). <b>var</b> es, en esencia, el método antiguo para crear variables, y aunque aún se puede usar, hoy en día se recomienda utilizar formas más modernas de declarar variables, como let y const.
                    </p>
                    <br>
                    <p>
                        Las variables declaradas con <b>var</b> tienen un <b>ámbito funcional</b> (function scope). Esto significa que esas variables están disponibles dentro de toda la función en la que fueron declaradas, y no son accesibles fuera de esa función. Si la variable se declara fuera de cualquier función, será global.
                    </p>
                    <p>
                        Ejemplo:   
                    </p>
                    <pre><code>
function testVar() {
    var x = 10;
    if (true) {
        var x = 20; // redefinimos x dentro del bloque if
        console.log(x); // 20
    }
    console.log(x); // 20, porque x fue cambiada dentro del bloque if
}
                    </code></pre>
                    <p>
                        En este ejemplo, la variable <b>x</b> se redefine dentro del bloque <b>if</b>, y su valor cambia tanto dentro como fuera del bloque. Esto se debe a que <b>var</b> tiene un ámbito funcional.
                    </p>
                    <br>
                    <p>
                        Puedes declarar una variable usando <b>var</b> varias veces dentro del mismo ámbito, y esto no causará un error. Sin embargo, es importante tener en cuenta que la segunda declaración sobrescribirá el valor de la variable, lo que puede generar comportamientos inesperados en tu código.
                    </p>
                    <p>
                        Ejemplo:   
                    </p>
                    <pre><code>
var x = 10;
var x = 20; // No hay error, pero x ahora tiene el valor 20

console.log(x); // 20
                    </code></pre>
                    <p>
                        En este ejemplo, la variable <b>x</b> se declara dos veces con <b>var</b>, y no se produce ningún error. Sin embargo, el valor de <b>x</b> cambia a <b>20</b> después de la segunda declaración.
                    </p>
                    <br>
                    <p>
                        <i class="underlined">¿Cuándo se utiliza <b>var</b>?</i>
                    </p>
                    <ul>
                        <li>Cuando necesitas compatibilidad con versiones antiguas de JavaScript.</li>
                        <li>Cuando no te importa el ámbito de la variable.</li>
                        <li>Cuando estás trabajando en un código heredado que ya utiliza <b>var</b>.</li>
                    </ul>
                    <p>
                        Aunque var sigue funcionando en JavaScript, su uso puede provocar errores difíciles de depurar, especialmente si se olvida cómo funciona el ámbito (scope). Esto fue solucionado con la introducción de let y const en ES6.
                    </p>
                    <hr>
                    <p>
                        &#128204; <b>let</b> - es una palabra clave que se introdujo en ES6 y se utiliza para declarar variables con un <b>ámbito de bloque</b> (block scope). Esto significa que las variables declaradas con let solo están disponibles dentro del bloque en el que fueron declaradas (por ejemplo, dentro de un bucle o una declaración if).
                    </p>
                    <p>
                        Ejemplo:
                    </p>
                    <pre><code>
if (true) {
    let a = 10;
    console.log(a); // 10
}
console.log(a); // Error: a no está definido, ya que solo existe dentro del bloque if
                    </code></pre>
                    <p>
                        En este ejemplo, la variable <b>a</b> se declara dentro del bloque <b>if</b>, y no está disponible fuera de ese bloque. Esto ayuda a evitar conflictos de nombres y errores en el código.
                    </p>
                    <br>
                    <p>
                        Puedes declarar una variable usando <b>let</b> varias veces dentro del mismo ámbito, pero esto causará un error. Esto es diferente a <b>var</b>, donde puedes redeclarar variables sin problemas.
                    </p>
                    <p>
                        Ejemplo:   
                    </p>
                    <pre><code>
let a = 10;
let a = 20; // Error: la variable a ya ha sido declarada
                    </code></pre>
                    <p>
                        En este ejemplo, la variable <b>a</b> se declara dos veces con <b>let</b>, y esto causa un error porque no se permite redeclarar variables con let en el mismo ámbito.
                    </p>
                    <br>
                    <p>
                        <i class="underlined">¿Cuándo se utiliza <b>let</b>?</i>
                    </p>
                    <ul>
                        <li>Cuando necesitas una variable con un ámbito de bloque.</li>
                        <li>Cuando no necesitas que la variable sea global.</li>
                        <li>Cuando quieres evitar conflictos de nombres y errores en el código.</li>
                    </ul>
                    <p>
                        <b>let</b> es la opción más segura y moderna para declarar variables en JavaScript, y se recomienda su uso en la mayoría de los casos.
                    </p>
                    <hr>
                    <p>
                        &#128204; <b class="large-text">const</b> - es otra palabra clave introducida en ES6 que se utiliza para declarar variables con un <b>ámbito de bloque</b> (block scope), al igual que <b>let</b>. Sin embargo, la principal diferencia entre <b>const</b> y <b>let</b> es que las variables declaradas con <b>const</b> no pueden ser reasignadas después de su declaración. Esto significa que una vez que le das un valor a una variable con <b>const</b>, no puedes cambiar ese valor.
                    </p>
                    <p>
                        Ejemplo:
                    </p>
                    <pre><code>
const PI = 3.14;
PI = 3.14159; // Error: no se puede reasignar una variable const
                    </code></pre>
                    <p>
                        En este ejemplo, la variable <b>PI</b> se declara con <b>const</b>, y luego se intenta cambiar su valor. Esto causa un error porque no se permite reasignar variables declaradas con <b>const</b>.
                    </p>
                    <br>
                    <p>
                        Puedes declarar un objeto o un arreglo usando <b>const</b>, pero puedes modificar sus propiedades o elementos. Esto se debe a que el valor de la variable sigue siendo el mismo (la referencia al objeto o arreglo), pero puedes cambiar el contenido del objeto o arreglo.
                    </p>
                    <p>
                        Ejemplo:
                    </p>
                    <pre><code>
const person = {
    name: 'Juan',
    age: 30
};

person.age = 35; // Esto es válido, ya que estamos modificando una propiedad del objeto
console.log(person.age); // 35
                    </code></pre>
                    <p>
                        En este ejemplo, la variable <b>persona</b> se declara con <b>const</b>, pero se puede modificar la propiedad <b>edad</b> del objeto sin problemas.
                    </p>
                    <br>
                    <p>
                        <i class="underlined">¿Cuándo se utiliza <b>const</b>?</i>
                    </p>
                    <ul>
                        <li>Cuando necesitas una variable con un ámbito de bloque.</li>
                        <li>Cuando no necesitas que la variable sea reasignada.</li>
                        <li>Cuando quieres evitar errores de reasignación accidental.</li>
                        <li>Cuando trabajas con objetos o arreglos y no necesitas cambiar la referencia del objeto o arreglo.</li>
                    </ul>
                    <p>
                        <b>const</b> es una excelente opción para declarar variables que no deben cambiar, y se recomienda su uso en la mayoría de los casos donde no necesitas reasignar la variable.
                    </p>
                    <hr>
                    <p>
                        Cuando escribes código en JavaScript, elegir correctamente el tipo de variable es un paso importante para escribir un código claro, confiable y seguro.
                    </p>
                    <p>
                        En general, se recomienda usar <b>let</b> y <b>const</b> en lugar de <b>var</b>, ya que ofrecen un mejor control sobre el ámbito de las variables y ayudan a evitar errores comunes en el código. La mayoría de los desarrolladores modernos prefieren usar <b>let</b> y <b>const</b> para declarar variables, y solo usan <b>var</b> en casos específicos donde es necesario.
                    </p>
                    <div class="img-wrapper">
                        <img src="img/m4c8/variables.png" alt="Table of variables">
                    </div>
                </div>
                <div class="arrow-2">&#9650;</div>
            </div>
        </div>
<!-- 3 question -->
        <div class="question-answer">
            <div class="question-wrapper">
                <h3>3. ¿Qué es una función de flecha?</h3>
                <div class="arrow down">&#9650;</div>
            </div>
            <div class="answer-wrapper close">
                <div class="answer-contenido">
                    <p>
                        &#128204; <b class="large-text">Una función de flecha</b> (arrow function) es una forma más concisa de escribir funciones en JavaScript. Se introdujo en ES6 y se caracteriza por su sintaxis simplificada y su comportamiento especial con respecto al contexto de <b>this</b>.
                    </p>
                    <br>
                    <p>
                        La sintaxis básica de una función de flecha es la siguiente:
                    </p>
                    <pre><code>
const nameFunction = (parametros) => {
    // cuerpo de la función
}
                    </code></pre>
                    <p>
                        O, si la función tiene un solo parámetro, puedes omitir los paréntesis:
                    </p>
                    <pre><code>
const nameFunction = parametro => {
    // cuerpo de la función
}
                    </code></pre>
                    <p>
                        Y si la función tiene una sola expresión, puedes omitir las llaves y el return:
                    </p>
                    <pre><code>
const nameFunction = (parametros) => expresion;
                    </code></pre>
                    <br>
                    <p>
                        Ejemplo de una función de flecha:
                    </p>
                    <pre><code>
const suma = (a, b) => a + b;
console.log(suma(2, 3)); // 5
                    </code></pre>
                    <p>
                        En este ejemplo, la función <b>suma</b> toma dos parámetros <b>a</b> y <b>b</b>, y devuelve su suma. La sintaxis es más corta y fácil de leer que la forma tradicional de declarar funciones.
                    </p>
                    <p>
                        Ejemplo de una función normal:
                    </p>
                    <pre><code>
function suma(a, b) {
    return a + b;
}
console.log(suma(2, 3)); // 5
                    </code></pre>
                    <p>
                        El resultado de ambas funciones es el mismo: add(2, 3) devolverá 5. Como puedes ver, la función de flecha es más concisa y fácil de leer.
                    </p>
                    <br>
                    <p>
                        Una de las características más importantes de las funciones de flecha es que no tienen su propio contexto de <b>this</b>. Esto significa que el valor de <b>this</b> dentro de una función de flecha se hereda del contexto en el que se define la función. Esto es diferente a las funciones tradicionales, que crean su propio contexto de <b>this</b>.
                    </p>
                    <p>
                        Ejemplo:
                    </p>
                    <pre><code>
const object = {
    name: 'Juan',
    age: 30,
    greeting: function() {
        console.log(`Hola, soy ${this.name}`);
    }
};

objet.greeting(); // Hola, soy Juan
                    </code></pre>
                    <p>
                        En este ejemplo, la función <b>greeting</b> está definida dentro del objeto <b>object</b> y accede correctamente a la propiedad <b>name</b> usando <b>this</b>. Al ser una función normal (no flecha) y estar invocada como un método del objeto, <b>this</b> hace referencia al propio objeto <b>object</b>, lo que permite acceder a sus propiedades correctamente.
                    </p>
                    <br>
                    <p>
                        <i class="underlined">¿Cuándo se utiliza una <b>función de flecha?</b></i>
                    </p>
                    <ul>
                        <li>Cuando necesitas una sintaxis más concisa y legible para funciones simples.</li>
                        <li>Cuando quieres evitar problemas con el contexto de <b>this</b>.</li>
                        <li>Cuando trabajas con funciones de orden superior (funciones que toman otras funciones como argumentos).</li>
                        <li>Cuando necesitas una función que no se va a reutilizar en otros lugares.</li>
                    </ul>
                    <br>
                    <p>
                        Las funciones de flecha son una herramienta poderosa y útil en JavaScript, y su uso se ha vuelto común en el desarrollo moderno. Sin embargo, es importante recordar que no todas las funciones deben ser escritas como funciones de flecha. En algunos casos, las funciones tradicionales pueden ser más adecuadas, especialmente cuando necesitas un contexto de <b>this</b> diferente.
                    </p>
                    <div class="img-wrapper">
                        <img src="img/m4c8/arrow_function.png" alt="Arrow function">
                    </div>
                </div>
                <div class="arrow-2">&#9650;</div>
            </div>
        </div>
<!-- 4 question -->
        <div class="question-answer">
            <div class="question-wrapper">
                <h3>4. ¿Qué es la deconstrucción de variables?</h3>
                <div class="arrow down">&#9650;</div>
            </div>
            <div class="answer-wrapper close">
                <div class="answer-contenido">
                    <p>
                        <b class="large-text">La deconstrucción de variables</b> (destructuring) es una característica de JavaScript que permite extraer valores de arreglos u objetos y asignarlos a variables individuales de manera más concisa y legible. Esta característica fue introducida en ES6 y se ha vuelto muy popular entre los desarrolladores.
                    </p>
                    <p>
                        Supongamos que recibes un arreglo u objeto con varios valores y quieres asignar cada uno a su propia variable. En lugar de usar una larga cadena de asignaciones, puedes utilizar la desestructuración, que lo hace más corto y «limpio».
                    </p>
                    <hr>
                    <p>
                        &#128204; Al usar <b class="large-text">la deconstrucción de arreglos</b>, el orden de los elementos tiene un papel fundamental. Dado que los arreglos son colecciones ordenadas, sus valores se asignan a las variables según su posición. Esto significa que el primer valor del arreglo se asignará a la primera variable, el segundo al segundo, y así sucesivamente. Este enfoque resulta especialmente útil cuando conoces bien la estructura del arreglo y quieres extraer rápidamente los datos necesarios sin código innecesario.
                    </p>
                    <br>
                    <p>
                        Ejemplo sin deconstrucción:
                    </p>
                    <pre><code>
const rgb = [255, 100, 50];

const red = rgb[0];
const green = rgb[1];
const blue = rgb[2];

console.log(`Rojo: ${red}, Verde: ${green}, Azul: ${blue}`);
// Rojo: 255, Verde: 100, Azul: 50
                    </code></pre>
                    <p>
                        En este ejemplo, se asignan los valores del arreglo <b>rgb</b> a las variables <b>red</b>, <b>green</b> y <b>blue</b> utilizando el índice de cada elemento. Esto puede volverse tedioso si el arreglo tiene muchos elementos.
                    </p>
                    <br>
                    <p>
                        Ejemplo con deconstrucción:
                    </p>
                    <pre><code>
const rgb = [255, 100, 50];

const [red, green, blue] = rgb;

console.log(`Rojo: ${red}, Verde: ${green}, Azul: ${blue}`);
// Rojo: 255, Verde: 100, Azul: 50
                    </code></pre>
                    <p>
                        En este ejemplo, la deconstrucción de arreglos permite asignar los valores del arreglo <b>rgb</b> directamente a las variables <b>red</b>, <b>green</b> y <b>blue</b> en una sola línea de código.
                    </p>
                    <hr>
                    <p>
                        &#128204; Al usar <b class="large-text">la deconstrucción de objetos</b>, el orden no importa. Dado que los objetos son colecciones no ordenadas de pares clave-valor, puedes extraer los valores utilizando las claves correspondientes. Esto significa que puedes asignar valores a variables sin preocuparte por el orden en que aparecen en el objeto. Este enfoque es especialmente útil cuando trabajas con objetos complejos y necesitas acceder a propiedades específicas sin importar su posición.
                    </p>
                    <br>
                    <p>
                        Ejemplo sin deconstrucción:
                    </p>
                    <pre><code>
const person = {
    name: 'Juan',
    age: 30,
    city: 'Madrid'
};

const name = person.name;
const age = person.age;
const city = person.city;

console.log(`Nombre: ${name}, Edad: ${age}, Ciudad: ${city}`);
// Nombre: Juan, Edad: 30, Ciudad: Madrid
                    </code></pre>
                    <p>
                        En este ejemplo, se asignan los valores del objeto <b>person</b> a las variables <b>name</b>, <b>age</b> y <b>city</b> utilizando la clave de cada propiedad. Esto puede volverse tedioso si el objeto tiene muchas propiedades.
                    </p>
                    <br>
                    <p>
                        Ejemplo con deconstrucción:
                    </p>
                    <pre><code>
const person = {
    name: 'Juan',
    age: 30,
    city: 'Madrid'
};

const { name, age, city } = person;

console.log(`Nombre: ${name}, Edad: ${age}, Ciudad: ${city}`);
// Nombre: Juan, Edad: 30, Ciudad: Madrid
                    </code></pre>
                    <p>
                        En este ejemplo, la deconstrucción de objetos permite asignar los valores del objeto <b>person</b> directamente a las variables <b>name</b>, <b>age</b> y <b>city</b> en una sola línea de código.
                    </p>
                    <hr>
                    <p>
                        <b>La deconstrucción de variables</b> es una característica poderosa y útil en JavaScript que simplifica el proceso de asignación de valores a variables. Al utilizar la desestructuración, puedes escribir un código más limpio y legible, lo que facilita la comprensión y el mantenimiento del mismo.
                    </p>
                </div>
                <div class="arrow-2">&#9650;</div>
            </div>
        </div>
<!-- 5 question -->
        <div class="question-answer">
            <div class="question-wrapper">
                <h3>5. ¿Qué hace el operador de extensión en JS?</h3>
                <div class="arrow down">&#9650;</div>
            </div>
            <div class="answer-wrapper close">
                <div class="answer-contenido">
                    <p>
                        <b class="large-text">El operador de expansión</b> en JavaScript (también conocido como el <b class="large-text">spread</b> operator) es una sintaxis <b>...</b> que «despliega» (expande) los elementos de un arreglo o las propiedades de un objeto en lugares donde se esperan valores individuales.
                    </p>
                    <div class="flex-horizontal">
                        <div class="text-wrapper">
                            <p>
                                <i class="underlined">El operador de extensión se utiliza principalmente en dos contextos:</i>
                            </p>
                            <ul>
                                <li>Al crear nuevos arreglos u objetos, el operador de extensión permite combinar varios arreglos u objetos en uno solo, o copiar un arreglo u objeto existente.</li>
                                <li>Al pasar argumentos a funciones, el operador de extensión permite pasar los elementos de un arreglo como argumentos individuales a una función.</li>
                            </ul>
                        </div>
                        <div class="img-wrapper">
                            <img src="img/m4c8/spread.png" alt="Operator spread">
                        </div>
                    </div>




                    <hr>
                    <p>
                        &#128204; Al usar el <b>operador de extensión con arreglos</b>, puedes combinar varios arreglos en uno solo, copiar un arreglo o agregar elementos a un arreglo existente. Además, <b>spread</b> permite expandir un arreglo en una lista de argumentos para una función.
                    </p>
                    <br>
                    <p>
                        Ejemplo de <b>combinación de arreglos</b>:
                    </p>
                    <pre><code>
const arr1 = [1, 2, 3];
const arr2 = [4, 5, 6];

const combinedArr = [...arr1, ...arr2];
console.log(combinedArr); // [1, 2, 3, 4, 5, 6]
                    </code></pre>
                    <p>
                        En este ejemplo, el operador de extensión se utiliza para combinar los arreglos <b>arr1</b> y <b>arr2</b> en un nuevo arreglo llamado <b>combinedArr</b>.
                    </p>
                    <br>
                    <p>
                        Ejemplo de <b>copia de un arreglo</b>:
                    </p>
                    <pre><code>
const arr1 = [1, 2, 3];

const arr2 = [...arr1];
console.log(arr2); // [1, 2, 3]
                    </code></pre>
                    <p>
                        En este ejemplo, el operador de extensión se utiliza para crear una copia del arreglo <b>arr1</b> en un nuevo arreglo llamado <b>arr2</b>.
                    </p>
                    <br>
                    <p>
                        Ejemplo de <b>agregar elementos a un arreglo</b>:
                    </p>
                    <pre><code>
const arr1 = [1, 2, 3];
const arr2 = [4, 5, 6];

const combinedArr = [0, ...arr1, ...arr2, 7];
console.log(combinedArr); // [0, 1, 2, 3, 4, 5, 6, 7]
                    </code></pre>
                    <p>
                        En este ejemplo, el operador de extensión se utiliza para agregar elementos al centro del nuevo arreglo <b>combinedArr</b>.
                    </p>
                    <br>
                    <p>
                        Ejemplo de <b>pasar argumentos a una función</b>:
                    </p>
                    <pre><code>
const numbers = [1, 2, 3];
const sum = (a, b, c) => a + b + c;

const result = sum(...numbers);
console.log(result); // 6
                    </code></pre>
                    <p>
                        En este ejemplo, el operador de extensión se utiliza para pasar los elementos del arreglo <b>numbers</b> como argumentos individuales a la función <b>sum</b>.
                    </p>
                    <hr>
                    <p>
                        &#128204; Al usar <b>el operador de expansión con objetos</b>, puedes copiar un objeto existente, combinar varios objetos en uno solo o agregar nuevas propiedades a un objeto.
                    </p>
                    <br>
                    <p>
                        Ejemplo de <b>copia de un objeto</b>:
                    </p>
                    <pre><code>
const obj1 = { a: 1, b: 2 };

const obj2 = { ...obj1 };
console.log(obj2); // { a: 1, b: 2 }
                    </code></pre>
                    <p>
                        En este ejemplo, el operador de extensión se utiliza para crear una copia del objeto <b>obj1</b> en un nuevo objeto llamado <b>obj2</b>.
                    </p>
                    <br>
                    <p>
                        Ejemplo de <b>combinación de objetos</b>:
                    </p>
                    <pre><code>
const obj1 = { a: 1, b: 2 };
const obj2 = { c: 3, d: 4 };

const combinedObj = { ...obj1, ...obj2 };
console.log(combinedObj); // { a: 1, b: 2, c: 3, d: 4 }
                    </code></pre>
                    <p>
                        En este ejemplo, el operador de extensión se utiliza para combinar los objetos <b>obj1</b> y <b>obj2</b> en un nuevo objeto llamado <b>combinedObj</b>.
                    </p>
                    <br>
                    <p>
                        Ejemplo de <b>agregar propiedades a un objeto</b>:
                    </p>
                    <pre><code>
const user = { name: 'Olga' };
const updatedUser = { ...user, age: 30 };

console.log(updatedUser); // { name: 'Olga', age: 30 }
                    </code></pre>
                    <p>
                        En este ejemplo, el operador de extensión se utiliza para agregar propiedades al nuevo objeto <b>updatedUser</b>.
                    </p>
                </div>
                <div class="arrow-2">&#9650;</div>
            </div>
        </div>
<!-- 6 question -->       



















    </main>
    <footer>
        <p>&copy; 2025 Tetiana Kononenko</p>
    </footer>
    <script src="js/script.js"></script>
</body>
</html>