<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>M4C8</title>
    <link rel="stylesheet" href="css/commun.css">
    <link rel="stylesheet" href="css/questions_styles.css">
    <link rel="stylesheet" href="css/media_queries.css">
</head>
<body>
    <header>
        <h1>Preguntas teóricas del Punto de control 8</h1>
    </header>
    <main>
<!-- 1 question -->
        <div class="question-answer">
            <div class="question-wrapper">
                <h3>1. ¿Qué tipo de bucles hay en JS?</h3>
                <div class="arrow down">&#9650;</div>
            </div>
            <div class="answer-wrapper close">
                <div class="answer-contenido">
                    <p>
                        <b class="large-text">Un ciclo</b> es una construcción en programación que permite repetir el mismo bloque de código varias veces mientras se cumpla una determinada condición.
                    </p>
                    <div class="flex-vertical">
                        <div class="text-wrapper">
                            <p>
                                <i class="underlined">Los ciclos son útiles cuando se necesita:</i>
                            </p>
                            <ul>
                                <li>recorrer los elementos de un arreglo;</li>
                                <li>realizar una tarea muchas veces (por ejemplo, contar hasta 100);</li>
                                <li>solicitar la entrada del usuario hasta que introduzca un valor correcto;</li>
                                <li>automatizar acciones repetitivas.</li>
                            </ul>
                            <br>
                            <p>
                                <i class="underlined">En JavaScript hay varios tipos principales de ciclos:</i>
                            </p>
                            <ul>
                                <li><b>for</b> - ciclo con una cantidad conocida de repeticiones de antemano.</li>
                                <li><b>while</b> - ciclo con una cantidad desconocida de repeticiones, mientras se cumpla una condición.</li>
                                <li><b>do...while</b> - como while, pero el código se ejecuta al menos una vez.</li>
                                <li><b>for...in</b> - se utiliza para recorrer las propiedades de un objeto.</li>
                                <li><b>for...of</b> - se utiliza para recorrer los valores de objetos iterables (arreglos, cadenas, etc.).</li>
                            </ul>
                            <!-- <br> -->
                        </div>
                        <div class="img-wrapper">
                            <img src="img/m4c8/loops.jpg" alt="Loops JS">
                        </div>
                    </div>
                    <hr>
                    <p>
                        &#128204; <b class="large-text">El ciclo for</b> es un ciclo universal con un contador controlado. Se usa más comúnmente cuando se sabe de antemano cuántas veces se deben repetir las acciones.
                    </p>
                    <br>
                    <p>
                        Estructura del ciclo <b>for</b>:
                    </p>
                    <pre><code>
for (variable; condición; paso) {
    // cuerpo del ciclo
}
                    </code></pre>
                    <ul>
                        <li>se ejecuta el variable (por ejemplo, let i = 0) - esta es la inicialización;</li>
                        <li>se evalúa la condición (por ejemplo, i &lt; 5) - si es true, se ejecuta el cuerpo del ciclo;</li>
                        <li>después de ejecutar el cuerpo del ciclo, se realiza el paso (por ejemplo, i++ - incremento del contador);</li>
                        <li>se vuelve a verificar la condición, y así sucesivamente.</li>
                    </ul>
                    <br>
                    <p>
                        Ejemplo:
                    </p>
                    <pre><code>
for (let i = 1; i &lt;= 3; i++) {
    console.log(`Iteración número ${i}`);
}

// Iteración número 1  
// Iteración número 2  
// Iteración número 3
                    </code></pre>
                    <br>
                    <p>
                        <i class="underlined">¿Cuándo se utiliza el ciclo <b>for</b>?</i>
                    </p>
                    <ul>
                        <li>Cuando se conoce la cantidad exacta de iteraciones.</li>
                        <li>Al recorrer un arreglo por índices.</li>
                        <li>Cuando se necesita controlar el paso (por ejemplo, i += 2, i--).</li>
                    </ul>
                    <hr>
                    <p>
                        &#128204; <b class="large-text">El ciclo while</b> ejecuta un bloque de código mientras la condición sea verdadera (true). Es útil cuando no se sabe de antemano cuántas veces se deben repetir las acciones.
                    </p>
                    <br>
                    <p>
                        Estructura del ciclo <b>while</b>:
                    </p>
                    <pre><code>
while (condición) {
  // cuerpo del ciclo
}
                    </code></pre>
                    <ul>
                        <li>primero se verifica la condición;</li>
                        <li>si la condición es true, se ejecuta el cuerpo del ciclo;</li>
                        <li>luego, se vuelve a verificar la condición;</li>
                        <li>esto se repite mientras la condición siga siendo verdadera;</li>
                    </ul>
                    <p>
                        Si la condición es <i>false</i> desde el principio, el cuerpo del ciclo no se ejecutará ni una sola vez.
                    </p>
                    <br>
                    <p>
                        Ejemplo:
                    </p>
                    <pre><code>
let number = 1;

while (number &lt;= 3) {
  console.log(`Número: ${number}`);
  number++;
}

// Número: 1  
// Número: 2  
// Número: 3
                    </code></pre>
                    <br>
                    <p>
                        <i class="underlined">¿Cuándo se utiliza el ciclo <b>while</b>?</i>
                    </p>
                    <ul>
                        <li>Cuando no sabes cuántas iteraciones serán necesarias.</li>
                        <li>Por ejemplo, al recibir datos del usuario, cuando necesitas esperar una entrada válida.</li>
                        <li>Al esperar un evento o estado (por ejemplo, la carga de datos).</li>
                    </ul>
                    <hr>
                    <p>
                        &#128204; <b class="large-text">El ciclo do...while</b> es similar al ciclo <b>while</b>, pero garantiza que el cuerpo del ciclo se ejecute al menos una vez, incluso si la condición es falsa desde el principio.
                    </p>
                    <br>
                    <p>
                        Estructura del ciclo <b>do...while</b>:
                    </p>
                    <pre><code>
do {
  // cuerpo del ciclo
} while (condición);
                    </code></pre>
                    <ul>
                        <li>se ejecuta el cuerpo del ciclo una vez;</li>
                        <li>luego se verifica la condición;</li>
                        <li>si la condición es true, el ciclo se repite;</li>
                        <li>si es false, el ciclo termina.</li>
                    </ul>
                    <br>
                    <p>
                        Ejemplo:
                    </p>
                    <pre><code>
let i = 5;

do {
  console.log(`Esto se imprimirá al menos una vez i = ${i}`);
  i++;
} while (i &lt; 3);

// Esto se imprimirá al menos una vez i = 5
                    </code></pre>
                    <br>
                    <p>
                        <i class="underlined">¿Cuándo se utiliza el ciclo <b>do...while</b>?</i>
                    </p>
                    <ul>
                        <li>Cuando necesitas asegurarte de que el cuerpo del ciclo se ejecute al menos una vez.</li>
                        <li>Por ejemplo, al pedir una contraseña antes de iniciar sesión — se debe solicitar la entrada al menos una vez.</li>
                        <li>Cuando la verificación debe hacerse después de ejecutar la acción.</li>
                    </ul>
                    <hr>
                    <p>
                        &#128204; <b class="large-text">El ciclo for...in</b> se utiliza para recorrer las propiedades de un objeto. Es útil cuando necesitas acceder a todas las propiedades de un objeto sin importar su orden.
                    </p>
                    <br>
                    <p>
                        Estructura del ciclo <b>for...in</b>:
                    </p>
                    <pre><code>
for (let clave in objeto) {
  // cuerpo del ciclo
}
                    </code></pre>
                    <ul>
                        <li>se declara una variable (por ejemplo, clave) que tomará el nombre de cada propiedad del objeto;</li>
                        <li>el cuerpo del ciclo se ejecuta para cada propiedad del objeto.</li>
                    </ul>
                    <br>
                    <p>
                        Ejemplo:
                    </p>
                    <pre><code>
let user = {
  nombre: 'Elena',
  edad: 30,
  ciudad: 'Kazan'
};

for (let clave in user) {
  console.log(clave + ": " + user[clave]);
}

// nombre: Elena
// edad: 30
// ciudad: Kazan
                    </code></pre>
                    <br>
                    <p>
                        <i class="underlined">¿Cuándo se utiliza el ciclo <b>for...in</b>?</i>
                    </p>
                    <ul>
                        <li>Cuando necesitas recorrer las propiedades de un objeto.</li>
                        <li>Cuando no importa el orden de las propiedades.</li>
                        <li>Cuando no necesitas acceder a los valores de un arreglo por índice.</li>
                    </ul>
                    <hr>
                    <p>
                        &#128204; <b class="large-text">El ciclo for...of</b> se utiliza para recorrer los valores de objetos iterables (arreglos, cadenas, etc.). Es útil cuando necesitas acceder a los valores sin preocuparte por los índices.
                    </p>
                    <br>
                    <p>
                        Estructura del ciclo <b>for...of</b>:
                    </p>
                    <pre><code>
for (let variable of colección) {
  // cuerpo del ciclo
}
                    </code></pre>
                    <ul>
                        <li>se declara una variable (por ejemplo, variable) que tomará el valor de cada elemento de la colección;</li>
                        <li>el cuerpo del ciclo se ejecuta para cada elemento de la colección.</li>
                    </ul>
                    <br>
                    <p>
                        Ejemplo:
                    </p>
                    <pre><code>
let names = ['Anna', 'Boris', 'Víctor'];

for (let name of names) {
  console.log(`Hola, ${name}!`);
}

// Hola, Anna!
// Hola, Boris!
// Hola, Víctor!
                    </code></pre>
                    <br>
                    <p>
                        <i class="underlined">¿Cuándo se utiliza el ciclo <b>for...of</b>?</i>
                    </p>
                    <ul>
                        <li>Cuando necesitas recorrer los valores de un objeto iterable.</li>
                        <li>Cuando no necesitas preocuparte por los índices.</li>
                        <li>Cuando no necesitas acceder a las propiedades del objeto.</li>
                    </ul>
                </div>
                <div class="arrow-2">&#9650;</div>
            </div>
        </div>
<!-- 2 question -->
        <div class="question-answer">
            <div class="question-wrapper">
                <h3>2. ¿Cuáles son las diferencias entre const, let y var?</h3>
                <div class="arrow down">&#9650;</div>
            </div>
            <div class="answer-wrapper close">
                <div class="answer-contenido">
                    <p>
                        Cuando comenzamos a aprender a programar en JavaScript, una de las primeras cosas con las que nos encontramos es la declaración de variables. En JavaScript, existen tres palabras clave para esto: <b>let</b>, <b>const</b> y <b>var</b>. Todas se usan para crear variables, pero entre ellas existen diferencias importantes. Para entender mejor cómo y cuándo usar cada una de ellas, vamos a analizar cada una por separado.
                    </p>
                    <div class="img-wrapper">
                        <img src="img/m4c8/var_let_const.jpeg" alt="Variables JS">
                    </div>
                    <hr>
                    <p>
                        &#128204; <b class="large-text">var</b> - es una palabra clave que se utilizaba para declarar variables antes de la llegada de ES6 (la nueva versión de JavaScript que se lanzó en 2015). <b>var</b> es, en esencia, el método antiguo para crear variables, y aunque aún se puede usar, hoy en día se recomienda utilizar formas más modernas de declarar variables, como let y const.
                    </p>
                    <br>
                    <p>
                        Las variables declaradas con <b>var</b> tienen un <b>ámbito funcional</b> (function scope). Esto significa que esas variables están disponibles dentro de toda la función en la que fueron declaradas, y no son accesibles fuera de esa función. Si la variable se declara fuera de cualquier función, será global.
                    </p>
                    <p>
                        Ejemplo:   
                    </p>
                    <pre><code>
function testVar() {
    var x = 10;
    if (true) {
        var x = 20; // redefinimos x dentro del bloque if
        console.log(x); // 20
    }
    console.log(x); // 20, porque x fue cambiada dentro del bloque if
}
                    </code></pre>
                    <p>
                        En este ejemplo, la variable <b>x</b> se redefine dentro del bloque <b>if</b>, y su valor cambia tanto dentro como fuera del bloque. Esto se debe a que <b>var</b> tiene un ámbito funcional.
                    </p>
                    <br>
                    <p>
                        Puedes declarar una variable usando <b>var</b> varias veces dentro del mismo ámbito, y esto no causará un error. Sin embargo, es importante tener en cuenta que la segunda declaración sobrescribirá el valor de la variable, lo que puede generar comportamientos inesperados en tu código.
                    </p>
                    <p>
                        Ejemplo:   
                    </p>
                    <pre><code>
var x = 10;
var x = 20; // No hay error, pero x ahora tiene el valor 20

console.log(x); // 20
                    </code></pre>
                    <p>
                        En este ejemplo, la variable <b>x</b> se declara dos veces con <b>var</b>, y no se produce ningún error. Sin embargo, el valor de <b>x</b> cambia a <b>20</b> después de la segunda declaración.
                    </p>
                    <br>
                    <p>
                        <i class="underlined">¿Cuándo se utiliza <b>var</b>?</i>
                    </p>
                    <ul>
                        <li>Cuando necesitas compatibilidad con versiones antiguas de JavaScript.</li>
                        <li>Cuando no te importa el ámbito de la variable.</li>
                        <li>Cuando estás trabajando en un código heredado que ya utiliza <b>var</b>.</li>
                    </ul>
                    <p>
                        Aunque var sigue funcionando en JavaScript, su uso puede provocar errores difíciles de depurar, especialmente si se olvida cómo funciona el ámbito (scope). Esto fue solucionado con la introducción de let y const en ES6.
                    </p>
                    <hr>
                    <p>
                        &#128204; <b>let</b> - es una palabra clave que se introdujo en ES6 y se utiliza para declarar variables con un <b>ámbito de bloque</b> (block scope). Esto significa que las variables declaradas con let solo están disponibles dentro del bloque en el que fueron declaradas (por ejemplo, dentro de un bucle o una declaración if).
                    </p>
                    <p>
                        Ejemplo:
                    </p>
                    <pre><code>
if (true) {
    let a = 10;
    console.log(a); // 10
}
console.log(a); // Error: a no está definido, ya que solo existe dentro del bloque if
                    </code></pre>
                    <p>
                        En este ejemplo, la variable <b>a</b> se declara dentro del bloque <b>if</b>, y no está disponible fuera de ese bloque. Esto ayuda a evitar conflictos de nombres y errores en el código.
                    </p>
                    <br>
                    <p>
                        Puedes declarar una variable usando <b>let</b> varias veces dentro del mismo ámbito, pero esto causará un error. Esto es diferente a <b>var</b>, donde puedes redeclarar variables sin problemas.
                    </p>
                    <p>
                        Ejemplo:   
                    </p>
                    <pre><code>
let a = 10;
let a = 20; // Error: la variable a ya ha sido declarada
                    </code></pre>
                    <p>
                        En este ejemplo, la variable <b>a</b> se declara dos veces con <b>let</b>, y esto causa un error porque no se permite redeclarar variables con let en el mismo ámbito.
                    </p>
                    <br>
                    <p>
                        <i class="underlined">¿Cuándo se utiliza <b>let</b>?</i>
                    </p>
                    <ul>
                        <li>Cuando necesitas una variable con un ámbito de bloque.</li>
                        <li>Cuando no necesitas que la variable sea global.</li>
                        <li>Cuando quieres evitar conflictos de nombres y errores en el código.</li>
                    </ul>
                    <p>
                        <b>let</b> es la opción más segura y moderna para declarar variables en JavaScript, y se recomienda su uso en la mayoría de los casos.
                    </p>
                    <hr>
                    <p>
                        &#128204; <b class="large-text">const</b> - es otra palabra clave introducida en ES6 que se utiliza para declarar variables con un <b>ámbito de bloque</b> (block scope), al igual que <b>let</b>. Sin embargo, la principal diferencia entre <b>const</b> y <b>let</b> es que las variables declaradas con <b>const</b> no pueden ser reasignadas después de su declaración. Esto significa que una vez que le das un valor a una variable con <b>const</b>, no puedes cambiar ese valor.
                    </p>
                    <p>
                        Ejemplo:
                    </p>
                    <pre><code>
const PI = 3.14;
PI = 3.14159; // Error: no se puede reasignar una variable const
                    </code></pre>
                    <p>
                        En este ejemplo, la variable <b>PI</b> se declara con <b>const</b>, y luego se intenta cambiar su valor. Esto causa un error porque no se permite reasignar variables declaradas con <b>const</b>.
                    </p>
                    <br>
                    <p>
                        Puedes declarar un objeto o un arreglo usando <b>const</b>, pero puedes modificar sus propiedades o elementos. Esto se debe a que el valor de la variable sigue siendo el mismo (la referencia al objeto o arreglo), pero puedes cambiar el contenido del objeto o arreglo.
                    </p>
                    <p>
                        Ejemplo:
                    </p>
                    <pre><code>
const person = {
    name: 'Juan',
    age: 30
};

person.age = 35; // Esto es válido, ya que estamos modificando una propiedad del objeto
console.log(person.age); // 35
                    </code></pre>
                    <p>
                        En este ejemplo, la variable <b>persona</b> se declara con <b>const</b>, pero se puede modificar la propiedad <b>edad</b> del objeto sin problemas.
                    </p>
                    <br>
                    <p>
                        <i class="underlined">¿Cuándo se utiliza <b>const</b>?</i>
                    </p>
                    <ul>
                        <li>Cuando necesitas una variable con un ámbito de bloque.</li>
                        <li>Cuando no necesitas que la variable sea reasignada.</li>
                        <li>Cuando quieres evitar errores de reasignación accidental.</li>
                        <li>Cuando trabajas con objetos o arreglos y no necesitas cambiar la referencia del objeto o arreglo.</li>
                    </ul>
                    <p>
                        <b>const</b> es una excelente opción para declarar variables que no deben cambiar, y se recomienda su uso en la mayoría de los casos donde no necesitas reasignar la variable.
                    </p>
                    <hr>
                    <p>
                        Cuando escribes código en JavaScript, elegir correctamente el tipo de variable es un paso importante para escribir un código claro, confiable y seguro.
                    </p>
                    <p>
                        En general, se recomienda usar <b>let</b> y <b>const</b> en lugar de <b>var</b>, ya que ofrecen un mejor control sobre el ámbito de las variables y ayudan a evitar errores comunes en el código. La mayoría de los desarrolladores modernos prefieren usar <b>let</b> y <b>const</b> para declarar variables, y solo usan <b>var</b> en casos específicos donde es necesario.
                    </p>
                    <div class="img-wrapper">
                        <img src="img/m4c8/variables.png" alt="Table of variables">
                    </div>
                </div>
                <div class="arrow-2">&#9650;</div>
            </div>
        </div>
<!-- 3 question -->
        <div class="question-answer">
            <div class="question-wrapper">
                <h3>3. ¿Qué es una función de flecha?</h3>
                <div class="arrow down">&#9650;</div>
            </div>
            <div class="answer-wrapper close">
                <div class="answer-contenido">
                    <p>
                        &#128204; <b class="large-text">Una función de flecha</b> (arrow function) es una forma más concisa de escribir funciones en JavaScript. Se introdujo en ES6 y se caracteriza por su sintaxis simplificada y su comportamiento especial con respecto al contexto de <b>this</b>.
                    </p>
                    <br>
                    <p>
                        La sintaxis básica de una función de flecha es la siguiente:
                    </p>
                    <pre><code>
const nameFunction = (parametros) => {
    // cuerpo de la función
}
                    </code></pre>
                    <p>
                        O, si la función tiene un solo parámetro, puedes omitir los paréntesis:
                    </p>
                    <pre><code>
const nameFunction = parametro => {
    // cuerpo de la función
}
                    </code></pre>
                    <p>
                        Y si la función tiene una sola expresión, puedes omitir las llaves y el return:
                    </p>
                    <pre><code>
const nameFunction = (parametros) => expresion;
                    </code></pre>
                    <br>
                    <p>
                        Ejemplo de una función de flecha:
                    </p>
                    <pre><code>
const suma = (a, b) => a + b;
console.log(suma(2, 3)); // 5
                    </code></pre>
                    <p>
                        En este ejemplo, la función <b>suma</b> toma dos parámetros <b>a</b> y <b>b</b>, y devuelve su suma. La sintaxis es más corta y fácil de leer que la forma tradicional de declarar funciones.
                    </p>
                    <p>
                        Ejemplo de una función normal:
                    </p>
                    <pre><code>
function suma(a, b) {
    return a + b;
}
console.log(suma(2, 3)); // 5
                    </code></pre>
                    <p>
                        El resultado de ambas funciones es el mismo: add(2, 3) devolverá 5. Como puedes ver, la función de flecha es más concisa y fácil de leer.
                    </p>
                    <br>
                    <p>
                        Una de las características más importantes de las funciones de flecha es que no tienen su propio contexto de <b>this</b>. Esto significa que el valor de <b>this</b> dentro de una función de flecha se hereda del contexto en el que se define la función. Esto es diferente a las funciones tradicionales, que crean su propio contexto de <b>this</b>.
                    </p>
                    <p>
                        Ejemplo:
                    </p>
                    <pre><code>
const object = {
    name: 'Juan',
    age: 30,
    greeting: function() {
        console.log(`Hola, soy ${this.name}`);
    }
};

objet.greeting(); // Hola, soy Juan
                    </code></pre>
                    <p>
                        En este ejemplo, la función <b>greeting</b> está definida dentro del objeto <b>object</b> y accede correctamente a la propiedad <b>name</b> usando <b>this</b>. Al ser una función normal (no flecha) y estar invocada como un método del objeto, <b>this</b> hace referencia al propio objeto <b>object</b>, lo que permite acceder a sus propiedades correctamente.
                    </p>
                    <br>
                    <p>
                        <i class="underlined">¿Cuándo se utiliza una <b>función de flecha?</b></i>
                    </p>
                    <ul>
                        <li>Cuando necesitas una sintaxis más concisa y legible para funciones simples.</li>
                        <li>Cuando quieres evitar problemas con el contexto de <b>this</b>.</li>
                        <li>Cuando trabajas con funciones de orden superior (funciones que toman otras funciones como argumentos).</li>
                        <li>Cuando necesitas una función que no se va a reutilizar en otros lugares.</li>
                    </ul>
                    <br>
                    <p>
                        Las funciones de flecha son una herramienta poderosa y útil en JavaScript, y su uso se ha vuelto común en el desarrollo moderno. Sin embargo, es importante recordar que no todas las funciones deben ser escritas como funciones de flecha. En algunos casos, las funciones tradicionales pueden ser más adecuadas, especialmente cuando necesitas un contexto de <b>this</b> diferente.
                    </p>
                    <div class="img-wrapper">
                        <img src="img/m4c8/arrow_function.png" alt="Arrow function">
                    </div>
                </div>
                <div class="arrow-2">&#9650;</div>
            </div>
        </div>
<!-- 4 question -->
        <div class="question-answer">
            <div class="question-wrapper">
                <h3>4. ¿Qué es la deconstrucción de variables?</h3>
                <div class="arrow down">&#9650;</div>
            </div>
            <div class="answer-wrapper close">
                <div class="answer-contenido">
                    <p>
                        <b class="large-text">La deconstrucción de variables</b> (destructuring) es una característica de JavaScript que permite extraer valores de arreglos u objetos y asignarlos a variables individuales de manera más concisa y legible. Esta característica fue introducida en ES6 y se ha vuelto muy popular entre los desarrolladores.
                    </p>
                    <p>
                        Supongamos que recibes un arreglo u objeto con varios valores y quieres asignar cada uno a su propia variable. En lugar de usar una larga cadena de asignaciones, puedes utilizar la desestructuración, que lo hace más corto y «limpio».
                    </p>
                    <hr>
                    <p>
                        &#128204; Al usar <b class="large-text">la deconstrucción de arreglos</b>, el orden de los elementos tiene un papel fundamental. Dado que los arreglos son colecciones ordenadas, sus valores se asignan a las variables según su posición. Esto significa que el primer valor del arreglo se asignará a la primera variable, el segundo al segundo, y así sucesivamente. Este enfoque resulta especialmente útil cuando conoces bien la estructura del arreglo y quieres extraer rápidamente los datos necesarios sin código innecesario.
                    </p>
                    <br>
                    <p>
                        Ejemplo sin deconstrucción:
                    </p>
                    <pre><code>
const rgb = [255, 100, 50];

const red = rgb[0];
const green = rgb[1];
const blue = rgb[2];

console.log(`Rojo: ${red}, Verde: ${green}, Azul: ${blue}`);
// Rojo: 255, Verde: 100, Azul: 50
                    </code></pre>
                    <p>
                        En este ejemplo, se asignan los valores del arreglo <b>rgb</b> a las variables <b>red</b>, <b>green</b> y <b>blue</b> utilizando el índice de cada elemento. Esto puede volverse tedioso si el arreglo tiene muchos elementos.
                    </p>
                    <br>
                    <p>
                        Ejemplo con deconstrucción:
                    </p>
                    <pre><code>
const rgb = [255, 100, 50];

const [red, green, blue] = rgb;

console.log(`Rojo: ${red}, Verde: ${green}, Azul: ${blue}`);
// Rojo: 255, Verde: 100, Azul: 50
                    </code></pre>
                    <p>
                        En este ejemplo, la deconstrucción de arreglos permite asignar los valores del arreglo <b>rgb</b> directamente a las variables <b>red</b>, <b>green</b> y <b>blue</b> en una sola línea de código.
                    </p>
                    <hr>
                    <p>
                        &#128204; Al usar <b class="large-text">la deconstrucción de objetos</b>, el orden no importa. Dado que los objetos son colecciones no ordenadas de pares clave-valor, puedes extraer los valores utilizando las claves correspondientes. Esto significa que puedes asignar valores a variables sin preocuparte por el orden en que aparecen en el objeto. Este enfoque es especialmente útil cuando trabajas con objetos complejos y necesitas acceder a propiedades específicas sin importar su posición.
                    </p>
                    <br>
                    <p>
                        Ejemplo sin deconstrucción:
                    </p>
                    <pre><code>
const person = {
    name: 'Juan',
    age: 30,
    city: 'Madrid'
};

const name = person.name;
const age = person.age;
const city = person.city;

console.log(`Nombre: ${name}, Edad: ${age}, Ciudad: ${city}`);
// Nombre: Juan, Edad: 30, Ciudad: Madrid
                    </code></pre>
                    <p>
                        En este ejemplo, se asignan los valores del objeto <b>person</b> a las variables <b>name</b>, <b>age</b> y <b>city</b> utilizando la clave de cada propiedad. Esto puede volverse tedioso si el objeto tiene muchas propiedades.
                    </p>
                    <br>
                    <p>
                        Ejemplo con deconstrucción:
                    </p>
                    <pre><code>
const person = {
    name: 'Juan',
    age: 30,
    city: 'Madrid'
};

const { name, age, city } = person;

console.log(`Nombre: ${name}, Edad: ${age}, Ciudad: ${city}`);
// Nombre: Juan, Edad: 30, Ciudad: Madrid
                    </code></pre>
                    <p>
                        En este ejemplo, la deconstrucción de objetos permite asignar los valores del objeto <b>person</b> directamente a las variables <b>name</b>, <b>age</b> y <b>city</b> en una sola línea de código.
                    </p>
                    <hr>
                    <p>
                        <b>La deconstrucción de variables</b> es una característica poderosa y útil en JavaScript que simplifica el proceso de asignación de valores a variables. Al utilizar la desestructuración, puedes escribir un código más limpio y legible, lo que facilita la comprensión y el mantenimiento del mismo.
                    </p>
                </div>
                <div class="arrow-2">&#9650;</div>
            </div>
        </div>
<!-- 5 question -->
        <div class="question-answer">
            <div class="question-wrapper">
                <h3>5. ¿Qué hace el operador de extensión en JS?</h3>
                <div class="arrow down">&#9650;</div>
            </div>
            <div class="answer-wrapper close">
                <div class="answer-contenido">
                    <p>
                        <b class="large-text">El operador de expansión</b> en JavaScript (también conocido como el <b class="large-text">spread</b> operator) es una sintaxis <b>...</b> que «despliega» (expande) los elementos de un arreglo o las propiedades de un objeto en lugares donde se esperan valores individuales.
                    </p>
                    <div class="flex-horizontal">
                        <div class="text-wrapper">
                            <p>
                                <i class="underlined">El operador de extensión se utiliza principalmente en dos contextos:</i>
                            </p>
                            <ul>
                                <li>Al crear nuevos arreglos u objetos, el operador de extensión permite combinar varios arreglos u objetos en uno solo, o copiar un arreglo u objeto existente.</li>
                                <li>Al pasar argumentos a funciones, el operador de extensión permite pasar los elementos de un arreglo como argumentos individuales a una función.</li>
                            </ul>
                        </div>
                        <div class="img-wrapper">
                            <img src="img/m4c8/spread.png" alt="Operator spread">
                        </div>
                    </div>
                    <hr>
                    <p>
                        &#128204; Al usar el <b>operador de extensión con arreglos</b>, puedes combinar varios arreglos en uno solo, copiar un arreglo o agregar elementos a un arreglo existente. Además, <b>spread</b> permite expandir un arreglo en una lista de argumentos para una función.
                    </p>
                    <br>
                    <p>
                        Ejemplo de <b>combinación de arreglos</b>:
                    </p>
                    <pre><code>
const arr1 = [1, 2, 3];
const arr2 = [4, 5, 6];

const combinedArr = [...arr1, ...arr2];
console.log(combinedArr); // [1, 2, 3, 4, 5, 6]
                    </code></pre>
                    <p>
                        En este ejemplo, el operador de extensión se utiliza para combinar los arreglos <b>arr1</b> y <b>arr2</b> en un nuevo arreglo llamado <b>combinedArr</b>.
                    </p>
                    <br>
                    <p>
                        Ejemplo de <b>copia de un arreglo</b>:
                    </p>
                    <pre><code>
const arr1 = [1, 2, 3];

const arr2 = [...arr1];
console.log(arr2); // [1, 2, 3]
                    </code></pre>
                    <p>
                        En este ejemplo, el operador de extensión se utiliza para crear una copia del arreglo <b>arr1</b> en un nuevo arreglo llamado <b>arr2</b>.
                    </p>
                    <br>
                    <p>
                        Ejemplo de <b>agregar elementos a un arreglo</b>:
                    </p>
                    <pre><code>
const arr1 = [1, 2, 3];
const arr2 = [4, 5, 6];

const combinedArr = [0, ...arr1, ...arr2, 7];
console.log(combinedArr); // [0, 1, 2, 3, 4, 5, 6, 7]
                    </code></pre>
                    <p>
                        En este ejemplo, el operador de extensión se utiliza para agregar elementos al centro del nuevo arreglo <b>combinedArr</b>.
                    </p>
                    <br>
                    <p>
                        Ejemplo de <b>pasar argumentos a una función</b>:
                    </p>
                    <pre><code>
const numbers = [1, 2, 3];
const sum = (a, b, c) => a + b + c;

const result = sum(...numbers);
console.log(result); // 6
                    </code></pre>
                    <p>
                        En este ejemplo, el operador de extensión se utiliza para pasar los elementos del arreglo <b>numbers</b> como argumentos individuales a la función <b>sum</b>.
                    </p>
                    <hr>
                    <p>
                        &#128204; Al usar <b>el operador de expansión con objetos</b>, puedes copiar un objeto existente, combinar varios objetos en uno solo o agregar nuevas propiedades a un objeto.
                    </p>
                    <br>
                    <p>
                        Ejemplo de <b>copia de un objeto</b>:
                    </p>
                    <pre><code>
const obj1 = { a: 1, b: 2 };

const obj2 = { ...obj1 };
console.log(obj2); // { a: 1, b: 2 }
                    </code></pre>
                    <p>
                        En este ejemplo, el operador de extensión se utiliza para crear una copia del objeto <b>obj1</b> en un nuevo objeto llamado <b>obj2</b>.
                    </p>
                    <br>
                    <p>
                        Ejemplo de <b>combinación de objetos</b>:
                    </p>
                    <pre><code>
const obj1 = { a: 1, b: 2 };
const obj2 = { c: 3, d: 4 };

const combinedObj = { ...obj1, ...obj2 };
console.log(combinedObj); // { a: 1, b: 2, c: 3, d: 4 }
                    </code></pre>
                    <p>
                        En este ejemplo, el operador de extensión se utiliza para combinar los objetos <b>obj1</b> y <b>obj2</b> en un nuevo objeto llamado <b>combinedObj</b>.
                    </p>
                    <br>
                    <p>
                        Ejemplo de <b>agregar propiedades a un objeto</b>:
                    </p>
                    <pre><code>
const user = { name: 'Olga' };
const updatedUser = { ...user, age: 30 };

console.log(updatedUser); // { name: 'Olga', age: 30 }
                    </code></pre>
                    <p>
                        En este ejemplo, el operador de extensión se utiliza para agregar propiedades al nuevo objeto <b>updatedUser</b>.
                    </p>
                </div>
                <div class="arrow-2">&#9650;</div>
            </div>
        </div>
<!-- 6 question -->
        <div class="question-answer">
            <div class="question-wrapper">
                <h3>6. ¿Qué es la programación orientada a objetos?</h3>
                <div class="arrow down">&#9650;</div>
            </div>
            <div class="answer-wrapper close">
                <div class="answer-contenido">
                    <p>
                        <b class="large-text">La programación orientada a objetos</b> (POO) es una forma de codificación que permite crear diversos objetos a partir de otro objeto. En el proceso de diseño se utiliza un llamado constructor, cuyo principio de funcionamiento se basa en los objetos, su creación e interacción.
                    </p>
                    <p>
                        Un objeto general es un plano. También puede llamarse proyecto o esquema. Los elementos creados a partir de él son llamados instancias.
                    </p>
                    <p>
                        En la POO, un objeto es una instancia de una clase, que es una plantilla o modelo que define las propiedades y métodos que tendrá el objeto. Las propiedades son los datos que describen el objeto, mientras que los métodos son las funciones que definen el comportamiento del objeto.
                    </p>
                    <br>
                    <p>
                        <i class="underlined">La POO se basa en cuatro conceptos fundamentales:</i>
                    </p>
                    <ul>
                        <li><b>Encapsulamiento</b>: Agrupa datos y métodos relacionados en un solo objeto, ocultando la implementación interna y exponiendo solo lo necesario.</li>
                        <li><b>Herencia</b>: Permite crear nuevas clases basadas en clases existentes, heredando propiedades y métodos de la clase padre.</li>
                        <li><b>Polimorfismo</b>: Permite que diferentes clases implementen el mismo método de diferentes maneras, lo que facilita la reutilización del código.</li>
                        <li><b>Abstracción</b>: Permite representar conceptos complejos mediante modelos simplificados, ocultando detalles innecesarios.</li>
                    </ul>
                    <br>
                    <p>
                        La programación orientada a objetos (POO) es un enfoque poderoso para organizar y estructurar el código, lo que facilita la creación de aplicaciones complejas y escalables. Gracias a este paradigma, los desarrolladores pueden escribir código más modular, reutilizable y fácil de mantener.
                    </p>
                    <p>
                        Este enfoque resulta especialmente útil en proyectos grandes, donde una buena organización y la reutilización de componentes son clave para el éxito. Además, promueve la colaboración entre los miembros del equipo, ya que permite dividir el trabajo en módulos y componentes independientes que pueden desarrollarse y probarse por separado.
                    </p>
                    <hr>
                    <p>
                        &#128204; En JavaScript, la POO se implementa utilizando <b class="large-text">funciones constructoras</b> y <b class="large-text">prototipos</b>. Las funciones constructoras son funciones especiales que se utilizan para crear objetos, mientras que los prototipos permiten compartir métodos y propiedades entre objetos.
                    </p>
                    <br>
                    <p>
                        Ejemplo de una <b>función constructora</b>:
                    </p>
                    <pre><code>
function Person(name, age) {
    this.name = name;
    this.age = age;
    this.greet = function() {
        console.log(`Hola, soy ${this.name} y tengo ${this.age} años.`);
    }
}

const person1 = new Person('Juan', 30);
const person2 = new Person('María', 25);
person1.greet(); // Hola, soy Juan y tengo 30 años.
person2.greet(); // Hola, soy María y tengo 25 años.
                    </code></pre>
                    <p>
                        En este ejemplo, la función constructora <b>Person</b> se utiliza para crear objetos <b>person1</b> y <b>person2</b>, que tienen propiedades <b>name</b> y <b>age</b>, así como un método <b>greet</b>.
                    </p>
                    <hr>
                    <p>
                        &#128204; <b class="large-text">La herencia</b> se implementa utilizando prototipos. Los prototipos permiten que un objeto herede propiedades y métodos de otro objeto, lo que facilita la creación de jerarquías de clases y la reutilización del código.
                    </p>
                    <br>
                    <p>
                        Ejemplo de <b>herencia</b>:
                    </p>
                    <pre><code>
function Animal(name) {
    this.name = name;
    this.speak = function() {
        console.log(`${this.name} hace un sonido.`);
    }
}

function Dog(name) {
    Animal.call(this, name); // Llama al constructor de Animal
    this.speak = function() {
        console.log(`${this.name} ladra.`);
    }
}

const dog = new Dog('Rex');
dog.speak(); // Rex ladra.
                    </code></pre>
                    <p>
                        En este ejemplo, la función constructora <b>Dog</b> hereda de la función constructora <b>Animal</b>, lo que le permite acceder a las propiedades y métodos de <b>Animal</b>.
                    </p>
                    <hr>
                    <p>
                        &#128204; <b class="large-text">El polimorfismo</b> es una característica clave de la POO que permite que diferentes clases implementen el mismo método de diferentes maneras. Esto facilita la reutilización del código y la creación de aplicaciones más flexibles y escalables.
                    </p>
                    <br>
                    <p>
                        Ejemplo de <b>polimorfismo</b>:
                    </p>
                    <pre><code>
function Animal(name) {
    this.name = name;
    this.speak = function() {
        console.log(`${this.name} hace un sonido.`);
    }
}

function Dog(name) {
    Animal.call(this, name); // Llama al constructor de Animal

    this.speak = function() {
        console.log(`${this.name} ladra.`);
    }
}

function Cat(name) {
    Animal.call(this, name); // Llama al constructor de Animal

    this.speak = function() {
        console.log(`${this.name} maulla.`);
    }
}

function Cow(name) {
    Animal.call(this, name); // Llama al constructor de Animal

    this.speak = function() {
        console.log(`${this.name} muge.`);
    }
}

const dog = new Dog('Rex');
const cat = new Cat('Miau');
const cow = new Cow('Lola');
dog.speak(); // Rex ladra.
cat.speak(); // Miau maulla.
cow.speak(); // Lola muge.
                    </code></pre>
                    <p>
                        En este ejemplo, las funciones constructoras <b>Dog</b>, <b>Cat</b> y <b>Cow</b> heredan de la función constructora <b>Animal</b>, pero cada una implementa su propio método <b>speak</b>. Esto permite que cada objeto tenga un comportamiento diferente al llamar al mismo método.
                    </p>
                    <div class="img-wrapper">
                        <img src="img/m4c8/polymorphism.png" alt="El polimorfismo">
                    </div>
                    <hr>
                    <p>
                        &#128204; <b class="large-text">La abstracción</b> es otro concepto clave de la POO que permite representar conceptos complejos mediante modelos simplificados. Esto se logra ocultando los detalles innecesarios y exponiendo solo lo necesario para interactuar con el objeto.
                    </p>
                    <br>
                    <p>
                        Ejemplo de <b>abstracción</b>:
                    </p>
                    <pre><code>
function Shape() {
    this.area = function() {
        throw new Error('Método no implementado');
    }

    this.perimeter = function() {
        throw new Error('Método no implementado');
    }
}

function Rectangle(width, height) {
    Shape.call(this); // Llama al constructor de Shape
    this.width = width;
    this.height = height;
    this.area = function() {
        return this.width * this.height;
    }

    this.perimeter = function() {
        return 2 * (this.width + this.height);
    }
}

function Circle(radius) {
    Shape.call(this); // Llama al constructor de Shape
    this.radius = radius;
    this.area = function() {
        return Math.PI * this.radius * this.radius;
    }

    this.perimeter = function() {
        return 2 * Math.PI * this.radius;
    }
}

const rectangle = new Rectangle(5, 10);
const circle = new Circle(3);
console.log(`Área del rectángulo: ${rectangle.area()}`); // Área del rectángulo: 50
console.log(`Perímetro del rectángulo: ${rectangle.perimeter()}`); // Perímetro del rectángulo: 30
console.log(`Área del círculo: ${circle.area()}`); // Área del círculo: 28.27
console.log(`Perímetro del círculo: ${circle.perimeter()}`); // Perímetro del círculo: 18.85
                    </code></pre>
                    <p>
                        En este ejemplo, la función constructora <b>Shape</b> define un método abstracto <b>area</b> y <b>perimeter</b>, que deben ser implementados por las clases derivadas <b>Rectangle</b> y <b>Circle</b>.
                    </p>
                </div>
                <div class="arrow-2">&#9650;</div>
            </div>
        </div>
<!-- 7 question -->
        <div class="question-answer">
            <div class="question-wrapper">
                <h3>7. ¿Qué es una promesa en JS?</h3>
                <div class="arrow down">&#9650;</div>
            </div>
            <div class="answer-wrapper close">
                <div class="answer-contenido">
                    <p>
                        &#128204; <b class="large-text">Una promesa</b> (promise) en JavaScript es un objeto que representa la eventual finalización (o falla) de una operación asíncrona y su valor resultante. Las promesas son una forma de manejar operaciones asíncronas en JavaScript, lo que permite escribir código más limpio y legible.
                    </p>
                    <br>
                    <p>
                        <i class="underlined">Una promesa puede estar en uno de los siguientes estados:</i>
                    </p>
                    <ul>
                        <li><b>Pendiente</b> (pending): El estado inicial, la operación aún no se ha completado.</li>
                        <li><b>Cumplida</b> (fulfilled): La operación se ha completado con éxito y la promesa tiene un valor resultante.</li>
                        <li><b>Rechazada</b> (rejected): La operación ha fallado y la promesa tiene un motivo de rechazo.</li>
                    </ul>
                    <br>
                    <p>
                        Ejemplo de <b>una promesa</b>:
                    </p>
                    <pre><code>
const myPromise = new Promise((resolve, reject) => {
    const exito = true; // Cambia a false para simular un error
    
    if (exito) {
        resolve('¡Todo salió bien!');
    } else {
        reject('Algo salió mal');
    }
});

myPromise
    .then(result => {
        console.log(result); // ¡Todo salió bien!
    })
    .catch(error => {
        console.error(error); // Algo salió mal
    });
                    </code></pre>
                    <p>
                        En este ejemplo, se crea una nueva promesa llamada <b>myPromise</b>. Dentro de la función constructora de la promesa, se simula una operación asíncrona que puede tener éxito o fallar. Si la operación tiene éxito, se llama a <b>resolve</b> con un mensaje de éxito. Si falla, se llama a <b>reject</b> con un mensaje de error.
                    </p>
                    <br>
                    <p>
                        <i class="underlined">Las promesas son útiles para:</i>
                    </p>
                    <ul>
                        <li>Manejar operaciones asíncronas de manera más legible y estructurada.</li>
                        <li>Evitar el llamado "callback hell" (infierno de callbacks) al encadenar promesas.</li>
                        <li>Proporcionar un manejo de errores más limpio y consistente.</li>
                    </ul>
                </div>
                <div class="arrow-2">&#9650;</div>
            </div>
        </div>
<!-- 8 question -->
        <div class="question-answer">
            <div class="question-wrapper">
                <h3>8. ¿Qué hacen async y await por nosotros?</h3>
                <div class="arrow down">&#9650;</div>
            </div>
            <div class="answer-wrapper close">
                <div class="answer-contenido">
                    <p>
                        <b class="large-text">Async</b> y <b class="large-text">Await</b> son dos palabras clave introducidas en ES2017 (ES8) que permiten trabajar con promesas de una manera más sencilla y legible. Estas palabras clave se utilizan para escribir código asíncrono de forma más similar al código síncrono, lo que facilita la comprensión y el mantenimiento del mismo.
                    </p>
                    <div class="img-wrapper">
                        <img src="img/m4c8/async_await.jpg" alt="Loops JS">
                    </div>
                    <hr>
                    <p>
                        &#128204; <b class="large-text">La palabra clave async</b> se utiliza para declarar una función asíncrona. Una función asíncrona es una función que siempre devuelve una promesa, y dentro de ella puedes usar la palabra clave <b>await</b> para esperar a que se resuelva una promesa antes de continuar con la ejecución del código.
                    </p>
                    <br>
                    <p>
                        Ejemplo de una <b>función asíncrona</b>:
                    </p>
                    <pre><code>
async function fetchData() {
    const response = await fetch('https://api.example.com/data');
    const data = await response.json();
    console.log(data);
}
                    </code></pre>
                    <p>
                        En este ejemplo, la función <b>fetchData</b> es una función asíncrona que utiliza <b>await</b> para esperar a que se resuelva la promesa devuelta por la función <b>fetch</b>. Esto permite que el código sea más legible y fácil de entender.
                    </p>
                    <br>
                    <p>
                        &#128204; <b class="large-text">La palabra clave await</b> se utiliza dentro de una función asíncrona para esperar a que se resuelva una promesa. Cuando se utiliza <b>await</b>, la ejecución de la función se pausa hasta que la promesa se resuelve, lo que permite escribir código asíncrono de manera más secuencial.
                    </p>
                    <br>
                    <p>
                        Ejemplo de uso de <b>await</b>:
                    </p>
                    <pre><code>
async function fetchData() {
    try {
        const response = await fetch('https://api.example.com/data');
        const data = await response.json();
        console.log(data);
    } catch (error) {
        console.error('Error al obtener los datos:', error);
    }
}
fetchData();
                    </code></pre>
                    <p>
                        En este ejemplo, la función <b>fetchData</b> utiliza <b>await</b> para esperar a que se resuelva la promesa devuelta por la función <b>fetch</b>. Si ocurre un error durante la obtención de los datos, se captura y se maneja en el bloque <b>catch</b>.
                    </p>
                    <hr>
                    <p>
                        <i class="underlined">Ventajas de usar <b>async</b> y <b>await</b>:</i>
                    </p>
                    <ul>
                        <li>Mejora la legibilidad del código al permitir escribir código asíncrono de manera más secuencial.</li>
                        <li>Facilita el manejo de errores utilizando bloques <b>try</b> y <b>catch</b>.</li>
                        <li>Reduce la complejidad del código al evitar el "callback hell".</li>
                        <li>Permite trabajar con promesas de manera más intuitiva.</li>
                    </ul>
                    <br>
                    <p>
                        En resumen, <b>async</b> y <b>await</b> son herramientas poderosas que facilitan el trabajo con promesas y operaciones asíncronas en JavaScript. Al utilizar estas palabras clave, puedes escribir código más limpio, legible y fácil de mantener.
                    </p>
                </div>
                <div class="arrow-2">&#9650;</div>
            </div>
        </div>
    </main>
    <footer>
        <p>&copy; 2025 Tetiana Kononenko</p>
    </footer>
    <script src="js/script.js"></script>
</body>
</html>